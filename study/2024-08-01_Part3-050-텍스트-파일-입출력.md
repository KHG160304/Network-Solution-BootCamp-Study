# 텍스트 파일의 입출력

- 콘솔의 문자 관련 입출력에서 gets_s, getc, getchar, putc, putchar, puts 함수를 사용한 것 처럼
  파일 입출력에서도, fgets_s, fgetc, fgetchar, fputc, fputchar, fputs  f가 붙은 함수들이 사용된다.
- 파일 입출력에서 파일은 fopen_s 로 파일을 새로 만들면, 0 바이트 짜리 파일이 만들어진다.
- 파일의 끝은 OS가 파일의 길이 정보를 따로 기록하며, 기록한 정보를 통해서 판별한다.
- RAM 메모리의 경우, 프로그래머가 필요한 만큼만 OS에 요청을 하였으며, OS의 허락 없이, 요청한 메모리 이상을 사용하려고 하면, 문제가 되었다,
- 그러나 파일 같은 경우는, 미리 용량을 할당 받는 절차가 없으며, 파일에 데이터를 write 하면 아무 문제 없이, 계속 용량이 증가한다. 문제 없이 write가 된다.

> ※ 파일 하나가 가질 수 있는 최대 용량이 정해져 있기는 하다.

- 파일에 데이터를 읽고 쓸 때, 주의해야 하는 것은, 파일의 위치 지정자가 어디를 가리키고 있는가 이다.
- 이전에 생성된 파일을 수정할 때, 파일 접근 모드를 r+ 로 지정하고, 파일 위치 지정자를 파일의 끝으로 옮겨주지 않고, 파일에 write를 수행하면, 이전에 기록된 데이터 위에, 새로운 데이터가 write 되어 버린다. 덮어쓰기가 되어, 이전 데이터가 유실되는 것이다.
- 기존의 로그 파일 같은 것도, 파일 접근 모드를 w 로 지정하여 파일을 열면, 데이터가 싹다 지워져버린다. 조심하자.
- fopen_s 에서 파일 경로 매개변수로 "CON" 을 넘겨주면, 콘솔 장치 파일을 여는 것과 같다.
  그리고나서, fgets_s 나 fputs 를 호출하면, 콘솔 입출력과 같다. 그냥, printf, scanf를 하는 것과 동일하다.
- stdin은 표준 입력 버퍼, stdout 표준 출력 버퍼 이다.
  매크로로 정의 되어 있으며, 얘들이 콘솔 표준 입출력 팡